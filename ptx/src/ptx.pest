// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#syntax
program = _{ SOI ~ statement* ~ EOI }
statement = _{ 
  directive
    | function_defn
}

directive = _{
  variable_declaration ~ ";"
  	| function_decl ~ ";"
    | version_directive
    | address_size_directive
    | target_directive
    | file_directive
    | loc_directive
	| section_directive
}

variable_declaration = {
	".constptr" ~ identifier ~ "," ~ identifier ~ "," ~ integer
    | variable_spec_list ~ identifier_spec ~ "=" ~ literal_operand
    | variable_spec_list ~ identifier_spec ~ "=" ~ initializer_list
  	| variable_spec_list ~ identifier_list
}
initializer_list = { "{" ~ initializer_list ~ "}" | "{" ~ literal_list ~ "}" }
literal_list = { literal_operand ~ "," ~ literal_list | literal_operand }
identifier_list = { identifier_spec ~ "," ~ identifier_list | identifier_spec }

block_spec = {
  ".maxntid" ~ integer ~ "," ~ integer ~ "," ~ integer
    | ".minnctapersm" ~ integer
    | ".maxnctapersm" ~ integer
}
block_spec_list = { block_spec ~ block_spec_list | block_spec }

function_defn = {
  function_decl ~ block_spec_list ~ function_statement_block
  | function_decl ~ function_statement_block
}


function_statement_block = { "{" ~ function_statement_list? ~ "}" }
function_statement = _{ 
	label
	| instruction_statement 
	| directive
	| prototype_block
	// we can have blocks of code ({ ... }) in function bodies
	| function_statement_block
}
function_statement_list = _{
	function_statement ~ function_statement_list | function_statement
}

// function_statement_list = _{
    //label ~ statement_list
    //| instruction_statement ~ statement_list
    //| directive ~ statement_list
    //| prototype_block ~ statement_list
    //| label
    //| instruction_statement
    //| directive
    // | statement_block
    // statement_block ~ statement_list
//}

// registerDeclaration | location | label | pragma | callprototype | calltargets;

// Instruction statement
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#instruction-statements
// | instruction ~ ";"
// | identifier ~ ":"
label = { identifier ~ ":" }
instruction_statement = {
	label? ~ predicate? ~ instruction ~ ";"
}
predicate = {
	"@!" ~ identifier
  	| "@" ~ identifier ~ (
  	  // note: equ must precede eq
      ".lt" | ".equ" | ".eq" | ".le" | ".ne" | ".ge"
        | ".gtu" | ".neu" | ".cf" | ".sf" | ".nsf"
    )? 
}
lohi_option = { ".lo" | ".hi" }

instruction = {
    opcode_spec ~ operand_list
    | opcode_spec
}
operand_list = _{ operand ~ "," ~ operand_list | operand }
operand = {
  // starts with % or WARP_SZ
  builtin_operand
  	// starts with \d 0x 0b 0\octets (int) 0f (float) 0d \d+.\d+ (double)
  	| literal_operand
    // tex_operand precedes due to "[" ...  ~ "," ~ "{" ... "}" "]"
    // precedes memory_operand, which is just "[" x | x+1 | 1 "]"
    | tex_operand
    | memory_operand
	// | array_operand
    // vector precedes due to "{" ... "}"
    | vector_operand
    // binary expression of identifiers always precede unary
    // | "-"? ~ identifier ~ ("+" | "|" | "\\") ~ integer ~ lohi_option?
    | ("!" | "-")? ~ identifier
}

// Built-in special operand.
builtin_operand = { special_register ~ dimension_modifier | special_register }


// Literal operand
//
// Example:
literal_operand = {
	// float always precedes because it starts with 0[fF]
    float_exact
    // double always precedes integers because it either
    // - contains a decimal point (.)
    // - starts with 0[dD]
    | double_exact
	| integer
}


// Texture operand
//
// Example:
// todo
tex_operand = { "[" ~ identifier ~ "," ~ vector_operand ~ "]" }


// Vector operand
//
// Example:
// .reg .v4 .f32 V;
// .reg .f32     a, b, c, d;
// mov.v4.f32 {a,b,c,d}, V;
vector_operand = {
	"-"? ~ "{" ~ identifier ~ ("," ~ identifier)* ~ "}"
}


// Memory operand
//
// Example:
// ld.shared.u16   r0,[0]; // [immOffset]
// ld.shared.u16   r0,[x]; // [var]
// ld.shared.u16   r0,[x+1]; // [var+immOffset]
// ld.shared.u16   r0,[r1]; // [reg]
// ld.shared.u16   r0,[r1+1]; // [reg+immOffset]
// ld.global.u32  s, a[0]; // var[immOffset]
// ld.global.u32  s, a[N-1]; // var[var+immOffset]
// mov.u32        s, a[1]; // var[immOffset]
memory_operand = {
	identifier ~ "[" ~ address_expression ~ "]"
	| "[" ~ address_expression ~ "]"
  	// | identifier ~ "[" ~ (twin_operand | address_expression | literal_operand) ~ "]"
    // | "-" ~ memory_operand
}

// Array operand
//
// Example:
// ld.global.u32  s, a[0];
// ld.global.u32  s, a[N-1];
// mov.u32        s, a[1];
array_operand = { identifier ~ "[" ~ address_expression ~ "]" }

twin_operand = {
	// todo: are we missing something here?
    identifier ~ "+=" ~ identifier ~ lohi_option?
    | identifier ~ "+=" ~ integer
    | identifier ~ "+" ~ identifier ~ lohi_option?
}

sign = { "+" | "-" }
address_expression = {
	// precedence because of the plus sign
    identifier ~ sign ~ integer
  	// | identifier ~ lohi_option?
  	| identifier
    | integer
}

opcode_spec = { opcode ~ option* }

// .entry kernel-name ( param-list )  kernel-body
// .entry kernel-name  kernel-body
// can we dedup variable_spec and var_spec
function_decl = {
  // can we remove this?
  // function_decl_header ~ "(" ~ function_param ~ ")" ~ function_name_and_parameters
  // function_decl_header ~ function_return_val? ~ function_name_and_parameters
  function_decl_header ~ function_return_val? ~ function_name ~ function_parameters?
  // | function_decl_header
}

// todo: refactor this
function_decl_header = {
  function_decl_header_entry
    | function_decl_header_visible_entry
    | function_decl_header_weak_entry
    | function_decl_header_func
    | function_decl_header_visible_func
    | function_decl_header_weak_func
    | function_decl_header_extern_func
}

function_decl_header_entry          = { ".entry" }
function_decl_header_visible_entry  = { ".visible" ~ ".entry" }
function_decl_header_weak_entry     = { ".weak" ~ ".entry" }
function_decl_header_func           = { ".func" }
function_decl_header_visible_func   = { ".visible" ~ ".func" }
function_decl_header_weak_func      = { ".weak" ~ ".func" }
function_decl_header_extern_func    = { ".extern" ~ ".func" }

function_name = @{ identifier }
function_return_val = { "(" ~ function_param ~ ")" }
function_param = {
  ".param" ~ variable_spec_list ~ ptr_spec? ~ identifier_spec
    | ".reg" ~ variable_spec_list ~ identifier_spec
}
function_param_list = _{
	function_param ~ "," ~ function_param_list
  	| function_param 
}
function_parameters = { "(" ~ function_param_list? ~ ")" }
// function_name_and_parameters = {
//  function_name ~ "(" ~ function_param_list? ~ ")" | function_name
// }

special_register = {
  "%clock"
    | "%halfclock"
    | "%clock64"
    | "%ctaid"
    | "%envreg" ~ ASCII_DIGIT+
    | "%gridid"
    | "%laneid"
    | "%lanemask_eq"
    | "%lanemask_le"
    | "%lanemask_lt"
    | "%lanemask_ge"
    | "%lanemask_gt"
    | "%nctaid"
    | "%ntid"
    | "%nsmid"
    | "%nwarpid"
    | "%pm" ~ ('0'..'7')
    | "%smid"
    | "%tid"
    | "%warpid"
    | "WARP_SZ"
}

dimension_modifier = { ".0" | ".1" | ".2" | ".x" | ".y" | ".z" }


identifier_spec = {
    identifier ~ "<" ~ integer ~ ">"
    | identifier ~ "[" ~ "]"
    | identifier ~ "[" ~ integer ~ "]"
    | identifier
}

address_size_directive = { ".address_size" ~ integer }

target_directive = { ".target" ~ identifier ~ ("," ~ identifier){0,2} }

// version_directive = { ".version" ~ double ~ "+"? }
version_directive = { ".version" ~ version_directive_major ~ "." ~ version_directive_minor ~ "+"? }
version_directive_major = @{ integer }
version_directive_minor = @{ integer }


// file_directive = { ".file" ~ integer ~ quoted ~ (("," ~ integer){2})? }
file_directive_timestamp = { integer }
file_directive_filesize = { integer }
file_directive = { 
	".file" ~ integer ~ quoted 
	~ ("," ~ file_directive_timestamp ~ "," ~ file_directive_filesize )?
}

section_directive = { ".section" ~ (debug_str_section)}
debug_str_section = { ".debug_str" ~ "{" ~ debug_str_list ~ "}"}
debug_str = { label | ".b8" ~ integer ~ ("," ~ integer)* }
debug_str_list = {
	debug_str ~ debug_str_list
	| debug_str
}

loc_directive = { ".loc" ~ integer ~ integer ~ integer ~ (("," ~ loc_attributes))* }
loc_attributes = { loc_function_name_attr | loc_inlined_at_attr }
// todo: identifier does not work as it does not recognize .debug_str..
// either we allow everything here (except for ",") or only .debug_str
loc_function_name_label = { identifier | ".debug_str" }
loc_function_name_attr = { "function_name" ~ loc_function_name_label ~ ("+" ~ integer)?}
loc_inlined_at_attr = { "inlined_at" ~ integer ~ integer ~ integer }

ptr_spec = {
  ".ptr" ~ ptr_space_spec ~ ptr_align_spec
    | ".ptr" ~ ptr_align_spec
}
ptr_space_spec = { ".global" | ".local" | ".shared" | ".const" }
ptr_align_spec = { ".align" ~ integer }
align_spec = { ".align" ~ integer }

variable_spec = {
  space_spec | type_spec | align_spec
    | ".visible" | ".extern" | ".weak"
}
variable_spec_list = {
	variable_spec ~ variable_spec_list
	| variable_spec
}


// this is a bit sketchy
// we cannot "group" well, because for example
// compare_spec contains a ".lo" and addressable_spec contains a ".local"
// because of that, we always need to make sure that ".local" (the more
// specific case) precedes ".lo"
option = {
    type_spec
    | addressable_spec
    | compare_spec
    | wmma_spec
    | rounding_mode
    | prmt_spec
    | atomic_operation_spec
    | ".sync"
    | ".arrive"
    | ".red"
    | ".uni"
    | ".wide"
    | ".any"
    | ".all"
    | ".ballot"
    | ".global"
    | ".cta"
    | ".sys"
    | ".1d"
    | ".2d"
    | ".3d"
    | ".sat"
    | ".ftz"
    | ".neg"
    | ".approx"
    | ".full"
    | ".exit"
    | ".abs"
    | ".to"
    | ".half"
    | ".extp"
    | ".ca"
    | ".cg"
    | ".cs"
    | ".lu"
    | ".cv"
    | ".wb"
    | ".wt"
    | ".nc"
    | ".up"
    | ".down"
    | ".bfly"
    | ".idx"
}
option_list = { option ~ option_list | option }

atomic_operation_spec = {
  ".and"
    | ".popc"
    | ".or"
    | ".xor"
    | ".cas"
    | ".exch"
    | ".add"
    | ".inc"
    | ".dec"
    | ".min"
    | ".max"
}
rounding_mode = { floating_point_rounding_mode | integer_rounding_mode }
floating_point_rounding_mode = { ".rn" | ".rz" | ".rm" | ".rp" }
integer_rounding_mode = { ".rni" | ".rzi" | ".rmi" | ".rpi" }

compare_spec = {
	// three chars
	".equ" | ".neu" | ".ltu" | ".leu"
	| ".gtu" | ".geu" | ".num" | ".nan"
	// two chars
	| ".eq" | ".ne" | ".lt" | ".le"
	| ".gt" | ".ge" | ".lo" | ".ls"
	| ".hi" | ".hs"
}
prmt_spec = { ".f4e" | ".b4e" | ".rc8" | ".rc16" | ".ecl" | ".ecr" }
wmma_spec = {
  wmma_directive ~ layout ~ configuration
    | wmma_directive ~ layout ~ layout ~ configuration
}
wmma_directive = { ".a.sync" | ".b.sync" | ".c.sync" | ".d.sync" | ".mma.sync" }
layout = { ".row" | ".col" }
configuration = { ".m16n16k16" | ".m32n8k16" | ".m8n32k16" }

prototype_block = { prototype_decl ~ prototype_call }
prototype_decl = {
  identifier ~ ":"
    ~ ".callprototype" ~ "(" ~ prototype_param? ~ ")"
    ~ identifier ~ "(" ~ prototype_param? ~ ")" ~ ";"
}
prototype_call = {
  opcode ~ "(" ~ identifier ~ ")" ~ ","
    ~ operand ~ "," ~ "(" ~ identifier ~ ")" ~ "," ~ identifier ~ ";"
    |
    opcode ~ identifier ~ ","
    ~ "(" ~ identifier ~ ")" ~ "," ~ identifier ~ ";"
}
prototype_param = { ".param" ~ (".b32" | ".b64") ~ identifier }
opcode = {
	// note: "addp" == "addc" > "add"
    // note: "andn" > "and"
  "abs" |  "addp" | "addc" | "add" | "andn" | "and" | "atom" | "activemask"
    // note: "bar.warp" > "bar"
    // note: "bfind" > "bfi"
    // note: "breakaddr" > "break"
    | "bar.warp" | "bar" | "bfe" | "bfind" | "bfi" | "bra" | "brx" | "brev" | "brkpt" | "breakaddr" | "break"
    // note: "callp" > "call"
    // note: "cvta" > "cvt"
    | "callp" | "call" | "clz" | "cnot" | "cos" | "cvta" | "cvt"
    | "div" | "dp4a"
    | "ex2" | "exit"
    | "fma"
    | "isspacep"
    // note: "ld.volatile" > "ldu" > "ld"
    | "ld.volatile" | "ldu" | "ld" | "lg2"
    // note: "mad24" > "madc" == "madp" > "mad"
    // note: "mul24" > "mul"
    | "mad24" | "madc" | "madp" | "mad" | "max" | "membar" | "min" | "mov" | "mul24" | "mul"
  	| "neg" | "nandn" | "norn" | "not" | "nop"
    // note: "orn" > "or"
    | "orn" | "or"
    // note: "prefetchu" > "prefetch"
    | "pmevent" | "popc" | "prefetchu" | "prefetch" | "prmt"
    // note: "retp" > "ret"
    | "rcp" | "red" | "rem" | "retp" | "ret" | "rsqrt"
    // note: "setp" > "set"
    // note: "st.volatile" > "st"
    // note: "subc" > "sub"
    | "sad" | "selp" | "setp" | "set" | "shfl" | "shl" | "shr" | "sin" | "slct" | "sqrt" | "sst" | "ssy" | "st.volatile" | "st" | "subc" | "sub" | "suld" | "sured" | "surst" | "suq"
  	| "tex" | "txq" | "trap"
    // note: "setp" > "set"
    | "vabsdiff" | "vadd" | "vmad" | "vmax" | "vmin" | "vset" | "vshl" | "vshr" | "vsub" | "vote"
    // note: "wmma.load" == "wmma.store" > "wmma"
    | "wmma.load" | "wmma.store" | "wmma"
    | "xor"
}

space_spec = { ".reg" | ".sreg" | addressable_spec }
addressable_spec = {
  ".const" | ".global"
    | ".local" | ".param" | ".shared"
    | ".sstarr" | ".surf" | ".tex"
}
type_spec = { vector_spec ~ scalar_type | scalar_type }
vector_spec = { ".v2" | ".v3" | ".v4" }
scalar_type = {
  ".s8" | ".s16" | ".s32" | ".s64"
    | ".u8" | ".u16" | ".u32" | ".u64"
    | ".f16" | ".f32" | ".f64" | ".ff64"
    | ".b8" | ".b16" | ".b32" | ".b64" | ".bb64" | ".bb128"
    | ".pred" | ".texref" | ".sampleref" | ".surfref"
}

quoted = _{ "\"" ~ string ~ "\"" }
string = ${ (!"\"" ~ ANY)* }

// Identifiers
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#identifiers
// followsym:	[a-zA-Z0-9_$]
// identifier:	[a-zA-Z]{followsym}* | {[_$%]{followsym}+
followsym = @{ "$" | "_" | ASCII_ALPHANUMERIC }
identifier = @{ ("_" | "$" | "%") ~ followsym+ | ASCII_ALPHA ~ followsym* }

// hex:			0[xX][0-9a-fA-F]+U?
// octal:		0[0-7]+U?
// binary:		0[bB][01]+U?
// decimal:		[-]?[0-9][0-9]*U?
integer = { 
  hex
    | octal
    | binary
    | decimal
}
// ascii_digit_nonzero = @{ "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"  }
ascii_digit_nonzero = @{ '1'..'9' }
// decimal = @{ "-"? ~ ascii_digit_nonzero ~ ASCII_DIGIT* ~ "U"? }
decimal = @{ "-"? ~ ASCII_DIGIT+ ~ "U"? }
hex = @{ "0" ~ ("x" | "X" ) ~ ASCII_HEX_DIGIT+ ~ "U"? }
binary = @{ "0" ~ ("b" | "B") ~ ASCII_BIN_DIGIT+ ~ "U"? }
octal = @{ "0" ~ ASCII_OCT_DIGIT+ ~ "U"? }

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#floating-point-constants
// 0[fF][0-9a-fA-F]{8}
float_exact = @{
  "0" ~ ("f" | "F") ~ ASCII_HEX_DIGIT{8}
}
// [0-9]+\.[0-9]+
// 0[dD][0-9a-fA-F]{16}
double = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
double_exact = { "0" ~ ("d" | "D") ~ ASCII_HEX_DIGIT{16} }

COMMENT = _{
  "/*" ~ (!"*/" ~ ANY)* ~ "*/" // multiline
    | "//" ~ (!"\n" ~ ANY)* // single line
}
WHITESPACE = _{ " " | "\t" | NEWLINE } // skip whitespace
